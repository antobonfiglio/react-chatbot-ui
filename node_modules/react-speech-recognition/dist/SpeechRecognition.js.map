{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///SpeechRecognition.js","webpack:///webpack/bootstrap 57782d76faa9b3a36737","webpack:///./src/SpeechRecognition.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","SpeechRecognition","options","SpeechRecognitionInner","WrappedComponent","BrowserSpeechRecognition","window","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","recognition","browserSupportsSpeechRecognition","listening","autoStart","start","pauseAfterDisconnect","interimTranscript","finalTranscript","_Component","SpeechRecognitionContainer","props","_this","getPrototypeOf","disconnect","disconnectType","abort","stop","resetTranscript","setState","startListening","continuous","DOMException","abortListening","stopListening","interimResults","onresult","updateTranscript","bind","onend","onRecognitionDisconnect","state","_createClass","key","event","i","resultIndex","results","length","isFinal","concatTranscripts","transcript","_len","arguments","transcriptParts","Array","_key","map","t","trim","join","_react2","createElement","_extends","_react","Component","defineProperty","assign","target","source","hasOwnProperty","defineProperties","descriptor","protoProps","staticProps"],"mappings":"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","file":"SpeechRecognition.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpeechRecognition\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"SpeechRecognition\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SpeechRecognition\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"SpeechRecognition\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.default = SpeechRecognition;\n\t\n\tvar _react = __webpack_require__(1);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction SpeechRecognition(options) {\n\t  var SpeechRecognitionInner = function SpeechRecognitionInner(WrappedComponent) {\n\t    var BrowserSpeechRecognition = typeof window !== 'undefined' && (window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition);\n\t    var recognition = BrowserSpeechRecognition ? new BrowserSpeechRecognition() : null;\n\t    var browserSupportsSpeechRecognition = recognition !== null;\n\t    var listening = void 0;\n\t    if (!browserSupportsSpeechRecognition || options && options.autoStart === false) {\n\t      listening = false;\n\t    } else {\n\t      recognition.start();\n\t      listening = true;\n\t    }\n\t    var pauseAfterDisconnect = false;\n\t    var interimTranscript = '';\n\t    var finalTranscript = '';\n\t\n\t    return function (_Component) {\n\t      _inherits(SpeechRecognitionContainer, _Component);\n\t\n\t      function SpeechRecognitionContainer(props) {\n\t        _classCallCheck(this, SpeechRecognitionContainer);\n\t\n\t        var _this = _possibleConstructorReturn(this, (SpeechRecognitionContainer.__proto__ || Object.getPrototypeOf(SpeechRecognitionContainer)).call(this, props));\n\t\n\t        _this.disconnect = function (disconnectType) {\n\t          if (recognition) {\n\t            switch (disconnectType) {\n\t              case 'ABORT':\n\t                pauseAfterDisconnect = true;\n\t                recognition.abort();\n\t                break;\n\t              case 'RESET':\n\t                pauseAfterDisconnect = false;\n\t                recognition.abort();\n\t                break;\n\t              case 'STOP':\n\t              default:\n\t                pauseAfterDisconnect = true;\n\t                recognition.stop();\n\t            }\n\t          }\n\t        };\n\t\n\t        _this.resetTranscript = function () {\n\t          interimTranscript = '';\n\t          finalTranscript = '';\n\t          _this.disconnect('RESET');\n\t          _this.setState({ interimTranscript: interimTranscript, finalTranscript: finalTranscript });\n\t        };\n\t\n\t        _this.startListening = function () {\n\t          if (recognition && !listening) {\n\t            if (!recognition.continuous) {\n\t              _this.resetTranscript();\n\t            }\n\t            try {\n\t              recognition.start();\n\t            } catch (DOMException) {\n\t              // Tried to start recognition after it has already started - safe to swallow this error\n\t            }\n\t            listening = true;\n\t            _this.setState({ listening: listening });\n\t          }\n\t        };\n\t\n\t        _this.abortListening = function () {\n\t          listening = false;\n\t          _this.setState({ listening: listening });\n\t          _this.disconnect('ABORT');\n\t        };\n\t\n\t        _this.stopListening = function () {\n\t          listening = false;\n\t          _this.setState({ listening: listening });\n\t          _this.disconnect('STOP');\n\t        };\n\t\n\t        if (browserSupportsSpeechRecognition) {\n\t          recognition.continuous = options.continuous !== false;\n\t          recognition.interimResults = true;\n\t          recognition.onresult = _this.updateTranscript.bind(_this);\n\t          recognition.onend = _this.onRecognitionDisconnect.bind(_this);\n\t        }\n\t\n\t        _this.state = {\n\t          interimTranscript: interimTranscript,\n\t          finalTranscript: finalTranscript,\n\t          listening: listening\n\t        };\n\t        return _this;\n\t      }\n\t\n\t      _createClass(SpeechRecognitionContainer, [{\n\t        key: 'onRecognitionDisconnect',\n\t        value: function onRecognitionDisconnect() {\n\t          listening = false;\n\t          if (pauseAfterDisconnect) {\n\t            this.setState({ listening: listening });\n\t          } else if (recognition) {\n\t            if (recognition.continuous) {\n\t              this.startListening();\n\t            } else {\n\t              this.setState({ listening: listening });\n\t            }\n\t          }\n\t          pauseAfterDisconnect = false;\n\t        }\n\t      }, {\n\t        key: 'updateTranscript',\n\t        value: function updateTranscript(event) {\n\t          interimTranscript = '';\n\t          for (var i = event.resultIndex; i < event.results.length; ++i) {\n\t            if (event.results[i].isFinal) {\n\t              finalTranscript = this.concatTranscripts(finalTranscript, event.results[i][0].transcript);\n\t            } else {\n\t              interimTranscript = this.concatTranscripts(interimTranscript, event.results[i][0].transcript);\n\t            }\n\t          }\n\t          this.setState({ finalTranscript: finalTranscript, interimTranscript: interimTranscript });\n\t        }\n\t      }, {\n\t        key: 'concatTranscripts',\n\t        value: function concatTranscripts() {\n\t          for (var _len = arguments.length, transcriptParts = Array(_len), _key = 0; _key < _len; _key++) {\n\t            transcriptParts[_key] = arguments[_key];\n\t          }\n\t\n\t          return transcriptParts.map(function (t) {\n\t            return t.trim();\n\t          }).join(' ').trim();\n\t        }\n\t      }, {\n\t        key: 'render',\n\t        value: function render() {\n\t          var transcript = this.concatTranscripts(finalTranscript, interimTranscript);\n\t\n\t          return _react2.default.createElement(WrappedComponent, _extends({\n\t            resetTranscript: this.resetTranscript,\n\t            startListening: this.startListening,\n\t            abortListening: this.abortListening,\n\t            stopListening: this.stopListening,\n\t            transcript: transcript,\n\t            recognition: recognition,\n\t            browserSupportsSpeechRecognition: browserSupportsSpeechRecognition\n\t          }, this.state, this.props));\n\t        }\n\t      }]);\n\t\n\t      return SpeechRecognitionContainer;\n\t    }(_react.Component);\n\t  };\n\t\n\t  if (typeof options === 'function') {\n\t    return SpeechRecognitionInner(options);\n\t  } else {\n\t    return SpeechRecognitionInner;\n\t  }\n\t}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// SpeechRecognition.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 57782d76faa9b3a36737","import React, { Component } from 'react'\n\nexport default function SpeechRecognition(options) {\n  const SpeechRecognitionInner = function (WrappedComponent) {\n    const BrowserSpeechRecognition =\n      typeof window !== 'undefined' &&\n      (window.SpeechRecognition ||\n        window.webkitSpeechRecognition ||\n        window.mozSpeechRecognition ||\n        window.msSpeechRecognition ||\n        window.oSpeechRecognition)\n    const recognition = BrowserSpeechRecognition\n      ? new BrowserSpeechRecognition()\n      : null\n    const browserSupportsSpeechRecognition = recognition !== null\n    let listening\n    if (\n      !browserSupportsSpeechRecognition ||\n      (options && options.autoStart === false)\n    ) {\n      listening = false\n    } else {\n      recognition.start()\n      listening = true\n    }\n    let pauseAfterDisconnect = false\n    let interimTranscript = ''\n    let finalTranscript = ''\n\n    return class SpeechRecognitionContainer extends Component {\n      constructor(props) {\n        super(props)\n\n        if (browserSupportsSpeechRecognition) {\n          recognition.continuous = options.continuous !== false\n          recognition.interimResults = true\n          recognition.onresult = this.updateTranscript.bind(this)\n          recognition.onend = this.onRecognitionDisconnect.bind(this)\n        }\n\n        this.state = {\n          interimTranscript,\n          finalTranscript,\n          listening\n        }\n      }\n\n      disconnect = disconnectType => {\n        if (recognition) {\n          switch (disconnectType) {\n            case 'ABORT':\n              pauseAfterDisconnect = true\n              recognition.abort()\n              break\n            case 'RESET':\n              pauseAfterDisconnect = false\n              recognition.abort()\n              break\n            case 'STOP':\n            default:\n              pauseAfterDisconnect = true\n              recognition.stop()\n          }\n        }\n      }\n\n      onRecognitionDisconnect() {\n        listening = false\n        if (pauseAfterDisconnect) {\n          this.setState({ listening })\n        } else if (recognition) {\n          if (recognition.continuous) {\n            this.startListening()\n          } else {\n            this.setState({ listening })\n          }\n        }\n        pauseAfterDisconnect = false\n      }\n\n      updateTranscript(event) {\n        interimTranscript = ''\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n          if (event.results[i].isFinal) {\n            finalTranscript = this.concatTranscripts(\n              finalTranscript,\n              event.results[i][0].transcript\n            )\n          } else {\n            interimTranscript = this.concatTranscripts(\n              interimTranscript,\n              event.results[i][0].transcript\n            )\n          }\n        }\n        this.setState({ finalTranscript, interimTranscript })\n      }\n\n      concatTranscripts(...transcriptParts) {\n        return transcriptParts.map(t => t.trim()).join(' ').trim()\n      }\n\n      resetTranscript = () => {\n        interimTranscript = ''\n        finalTranscript = ''\n        this.disconnect('RESET')\n        this.setState({ interimTranscript, finalTranscript })\n      }\n\n      startListening = () => {\n        if (recognition && !listening) {\n          if (!recognition.continuous) {\n            this.resetTranscript()\n          }\n          try {\n            recognition.start()\n          } catch (DOMException) {\n            // Tried to start recognition after it has already started - safe to swallow this error\n          }\n          listening = true\n          this.setState({ listening })\n        }\n      }\n\n      abortListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('ABORT')\n      }\n\n      stopListening = () => {\n        listening = false\n        this.setState({ listening })\n        this.disconnect('STOP')\n      }\n\n      render() {\n        const transcript = this.concatTranscripts(\n          finalTranscript,\n          interimTranscript\n        )\n\n        return (\n          <WrappedComponent\n            resetTranscript={this.resetTranscript}\n            startListening={this.startListening}\n            abortListening={this.abortListening}\n            stopListening={this.stopListening}\n            transcript={transcript}\n            recognition={recognition}\n            browserSupportsSpeechRecognition={browserSupportsSpeechRecognition}\n            {...this.state}\n            {...this.props} />\n        )\n      }\n    }\n  }\n\n  if (typeof options === 'function') {\n    return SpeechRecognitionInner(options)\n  } else {\n    return SpeechRecognitionInner\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SpeechRecognition.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}